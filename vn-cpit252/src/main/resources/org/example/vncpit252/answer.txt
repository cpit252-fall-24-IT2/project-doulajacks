The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance.|The pattern typically involves making the constructor private and using a static method to retrieve the instance.|It’s used when exactly one instance of a class is needed, such as for logging or managing a connection pool.|The implementation typically involves a static method that returns the single instance, which is created lazily (only when needed).|Advantages include controlled access to the instance and global access. Disadvantages include difficulty in testing and potential issues with global state.|The Prototype pattern is used to create new objects by cloning an existing object, which is useful when object creation is costly.|It allows objects to be copied instead of being created from scratch, thus saving time and resources.|It is preferred when object creation is complex or when you need to duplicate an object frequently with slight modifications.|In Java, the Prototype pattern is implemented by creating a `clone()` method in the class, and the class must implement the `Cloneable` interface.|Unlike the Singleton pattern, which ensures only one instance, the Prototype pattern allows for creating multiple instances by cloning.| The Adapter pattern is used to make two incompatible interfaces work together by creating an adapter class.|It works by converting the interface of a class into another interface expected by the client, allowing for compatibility between classes that couldn’t normally interact.|A real-world example would be using an adapter to connect a legacy system to a new system with a different interface.|The Adapter pattern decouples clients from incompatible interfaces, making it easier to integrate different systems.|In Java, it involves creating an Adapter class that wraps the existing class and converts its interface into a compatible one.|The Proxy pattern provides a surrogate or placeholder object that controls access to another object.|It allows for managing access to the real object, often controlling its creation or use (like lazy loading or access control).|Types include Virtual Proxy (for object creation), Remote Proxy (for accessing objects over a network), and Protection Proxy (for controlling access rights).|A real-world example is the use of proxy servers that control access to a website or manage internet connections.|In Java, you can create a proxy class that implements the same interface as the original class and controls access to it.|The Flyweight pattern is used to minimize memory usage by sharing objects that are identical, rather than creating new instances.|It reduces memory usage by sharing common parts of the object between instances and storing only unique parts separately.|The Flyweight pattern is ideal when you need to manage a large number of objects that share common states (like characters in a text editor).|An example is a text editor that uses a single object for each character type (e.g., `A`, `B`, `C`) and stores unique character positions separately.|In Java, the Flyweight pattern involves creating a `FlyweightFactory` that ensures shared objects are reused, with only unique states being stored separately.|The Builder pattern is used to construct a complex object step by step, allowing for different representations of the same type.|It separates the construction of an object from its representation, making it easier to create complex objects with multiple configurations.|It’s more flexible and readable than having a constructor with many parameters, especially when some parameters are optional or have default values.|In Java, the Builder pattern is typically implemented by creating a static nested `Builder` class that uses fluent methods to set properties.|An example where the Builder pattern is useful is in constructing complex objects like `HTML` documents, where you can specify attributes (like `class`, `id`) step by step.|
